<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;
using System.Threading;

using JetBrains.Annotations;

using NotNullIfNotNullAttribute = System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute;

namespace CodeJam.Threading
{
	/// <summary>
	/// Provides a helper class for initializing a values in a thread-safe manner.
	/// </summary>
	[PublicAPI]
	public static class InterlockedOperations
	{
<#
		var types = new[] { "double", "float", "int", "long" };
		foreach (var typeName in types)
		{
			WriteRegionLine(typeName + " overloads");
			EmitOverloadsFor(typeName, false);
		}

		WriteRegionLine("Generic overloads");
		EmitOverloadsFor("T", true);

		FlushRegions();
#>
	}
}<#+

	private void EmitOverloadsFor(string typeName, bool forRefTypes)
	{
		var t = typeName;
		var tXmlDoc = forRefTypes?
			"\r\n\t\t/// <typeparam name=\"" + typeName + "\">Type of value.</typeparam>" :
			"";
		var tXmlT = forRefTypes? "{" + typeName + "}" : "";
		var tT = forRefTypes? "<" + typeName + ">" : "";
		var tNotNull = forRefTypes? "[NotNull] " + typeName : typeName;
		var tWhere = forRefTypes? "\r\n\t\t\twhere " + typeName + " : class?" : "";
#>
		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="value"/> only if the current value is default(<#=t#>).
		/// </summary><#=tXmlDoc#>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="value">The value to use if the target is equal to default(<#=t#>).</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange<#=tXmlT#>(ref <#=t#>, <#=t#>, <#=t#>)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
        [return: NotNullIfNotNull("target")]
        public static <#=t#> Initialize<#=tT#>(ref <#=t#> target, <#=tNotNull#> value)<#=tWhere#> =>
			Initialize(ref target, value, default(<#=t#>));

		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="initializedValue"/> only if the current value
		/// is <paramref name="uninitializedValue"/>.
		/// </summary><#=tXmlDoc#>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
		/// <param name="uninitializedValue">The uninitialized value.</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange<#=tXmlT#>(ref <#=t#>, <#=t#>, <#=t#>)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
        [return: NotNullIfNotNull("target")]
		public static <#=t#> Initialize<#=tT#>(ref <#=t#> target, <#=t#> initializedValue, <#=t#> uninitializedValue)<#=tWhere#>
		{
			DebugCode.AssertArgument(
				initializedValue != uninitializedValue,
				nameof(initializedValue),
				"The values of uninitializedValue and initializedValue should not match");

			var oldValue = Interlocked.CompareExchange(ref target, initializedValue, uninitializedValue);
			return oldValue == uninitializedValue ? initializedValue : oldValue;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary><#=tXmlDoc#>
		/// <param name="value">Value to change.</param>
		/// <param name="updateCallback">Function to calculate new value.</param>
		/// <returns>New value.</returns>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		[return: NotNullIfNotNull("value")]
        public static <#=t#> Update<#=tT#>(ref <#=t#> value, Func<<#=t#>, <#=t#>> updateCallback)<#=tWhere#>
		{
			<#=t#> oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState);
				if (newState == oldState)
					return newState;
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary><#=tXmlDoc#>
		/// <param name="value">Value to change.</param>
		/// <param name="newValue">Precalculated new value.</param>
		/// <param name="updateCallback">Function to calculate new value.</param>
		/// <returns>New value.</returns>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
        [return: NotNullIfNotNull("value")]
        public static <#=t#> Update<#=tT#>(ref <#=t#> value, <#=t#> newValue, Func<<#=t#>, <#=t#>, <#=t#>> updateCallback)<#=tWhere#>
		{
			<#=t#> oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState, newValue);
				if (newState == oldState)
					return newState;
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}
<#+
	}
#>