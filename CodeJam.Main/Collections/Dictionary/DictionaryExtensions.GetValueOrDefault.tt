<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ import namespace="System.Reflection" #>
<#@include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

using JetBrains.Annotations;

using JBNotNull = JetBrains.Annotations.NotNullAttribute;

namespace CodeJam.Collections
{
	partial class DictionaryExtensions
	{
<#
// ReSharper disable UnusedMember.Local
var types =
new[]
{
	new {Name = "IDictionary", Conflict = false},
	new {Name = "IReadOnlyDictionary", Conflict = false},
	new {Name = "Dictionary", Conflict = false},
	new {Name = "ConcurrentDictionary", Conflict = false}
};
var self = GetType();
const BindingFlags flags = BindingFlags.Instance | BindingFlags.NonPublic;
var methodCount = self.GetMethods(flags).Count(m => m.Name.StartsWith("Header"));
foreach (var type in types) {#>
		#region <#=type.Name#><TKey, TValue> overloads
<#
	for (var i = 1; i <= methodCount; i++)
	{
		self.GetMethod("Header" + i, flags).Invoke(this, new object[] {type.Name});
		self.GetMethod((type.Conflict ? "Conflict" : "") + "Body" + i, flags).Invoke(this, new object[] {});
	}
#>
		#endregion

<#}#>
	}
}

namespace CodeJam.Collections.Backported
{
	/// <summary>
	/// Extensions for <see cref="IDictionary{TKey,TValue}"/>
	/// that are not included in previous FW versions
	/// </summary>
	public static class DictionaryExtensions
	{
<#
var backportedMethodCount = self.GetMethods(flags).Count(m => m.Name.StartsWith("BackportedHeader"));
foreach (var type in types) {#>
		#region <#=type.Name#><TKey, TValue> overloads
<#
	for (var i = 1; i <= backportedMethodCount; i++)
	{
		self.GetMethod("BackportedHeader" + i, flags).Invoke(this, new object[] {type.Name});
		self.GetMethod("Backported" + (type.Conflict ? "Conflict" : "") + "Body" + i, flags).Invoke(this, new object[] {});
	}
#>
		#endregion

<#}#>
	}
}
<#+
private void BackportedHeader1(string type) {#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or default(TValue) if key does not exists in
		/// <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or default value if <paramref name="key"/> does not exists
		/// in <paramref name="dictionary"/>
		/// </returns>
		[Pure, CanBeNull]
		[CollectionAccess(CollectionAccessType.Read)]
		[return: MaybeNull]
		public static TValue GetValueOrDefault<TKey, TValue>([JBNotNull] this <#=type#><TKey, TValue> dictionary, [JBNotNull] TKey key)
            where TKey : notnull =>
<#+}

private void BackportedBody1() {#>
			GetValueOrDefault(dictionary, key, default(TValue));

<#+}

private void BackportedConflictBody1() {#>
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key);

<#+}#>

<#+
private void BackportedHeader2(string type) {#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or <paramref name="defaultValue"/> if key does not exists
		/// in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="defaultValue">Default value.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or <paramref name="defaultValue"/> if <paramref name="key"/>
		/// does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure, CanBeNull]
		[CollectionAccess(CollectionAccessType.Read)]
		[return: MaybeNull]
		public static TValue GetValueOrDefault<TKey, TValue>(
			[JBNotNull] this <#=type#><TKey, TValue> dictionary,
			[JBNotNull] TKey key,
			[AllowNull][CanBeNull] TValue? defaultValue)
            where TKey : notnull
<#+}

private void BackportedBody2() {#>
		{
			Code.NotNull(dictionary, nameof(dictionary));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? result
					: defaultValue;
		}

<#+}

private void BackportedConflictBody2() {#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, defaultValue);
		}
<#+}#>

<#+
private void Header1(string type) {#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or default value if key does not exists
		/// in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <typeparam name="TResult">Result type.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="resultSelector">Function to select result.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or default value if <paramref name="key"/>
		/// does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure, CanBeNull]
		[CollectionAccess(CollectionAccessType.Read)]
		[return: MaybeNull]
		public static TResult GetValueOrDefault<TKey, TValue, TResult>(
				[JBNotNull] this <#=type#><TKey, TValue> dictionary,
				[JBNotNull] TKey key,
				[JBNotNull, InstantHandle] Func<TKey, TValue, TResult> resultSelector)
            where TKey : notnull =>
<#+}

private void Body1() {#>
			GetValueOrDefault(dictionary, key, resultSelector, default(TResult));

<#+}

private void ConflictBody1() {#>
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, resultSelector, default(TResult));

<#+}#>

<#+
private void Header2(string type) {#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or <paramref name="defaultValue"/> if key does not exists
		/// in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <typeparam name="TResult">Result type.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="resultSelector">Function to select result.</param>
		/// <param name="defaultValue">Default value.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or <paramref name="defaultValue"/> if <paramref name="key"/>
		/// does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		[return: MaybeNull]
		public static TResult GetValueOrDefault<TKey, TValue, TResult>(
			[JBNotNull] this <#=type#><TKey, TValue> dictionary,
			[JBNotNull] TKey key,
			[JBNotNull, InstantHandle] Func<TKey, TValue, TResult> resultSelector,
			[AllowNull][CanBeNull] TResult? defaultValue)
            where TKey : notnull
<#+}

private void Body2() {#>
		{
			Code.NotNull(dictionary, nameof(dictionary));
			Code.NotNull(resultSelector, nameof(resultSelector));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? resultSelector(key, result)
					: defaultValue;
		}

<#+}

private void ConflictBody2() {#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, resultSelector, defaultValue);
		}

<#+}#>

<#+
private void Header3(string type) {#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if key does not exists in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="defaultValueFactory">Function to return default value.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if <paramref name="key"/> does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		[return: MaybeNull]
		public static TValue GetValueOrDefault<TKey, TValue>(
			[JBNotNull] this <#=type#><TKey, TValue> dictionary,
			[JBNotNull] TKey key,
			[JBNotNull, InstantHandle] Func<TKey, TValue?> defaultValueFactory)
            where TKey : notnull
<#+}

		private void Body3() {#>
		{
			Code.NotNull(dictionary, nameof(dictionary));
			Code.NotNull(defaultValueFactory, nameof(defaultValueFactory));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? result
					: defaultValueFactory(key);
		}

<#+}

		private void ConflictBody3() {#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, defaultValueFactory);
		}

<#+}#>

<#+
		private void Header4(string type) {#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if key does not exists in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <typeparam name="TResult">Result type.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="defaultValueFactory">Function to return default value.</param>
		/// <param name="resultSelector">Function to select result.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if <paramref name="key"/> does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		[return: MaybeNull]
		public static TResult GetValueOrDefault<TKey, TValue, TResult>(
			[JBNotNull] this <#=type#><TKey, TValue> dictionary,
			[JBNotNull] TKey key,
			[JBNotNull, InstantHandle] Func<TKey, TValue, TResult?> resultSelector,
			[JBNotNull, InstantHandle] Func<TKey, TResult?> defaultValueFactory)
            where TKey : notnull
<#+}

		private void Body4() {#>
		{
			Code.NotNull(dictionary, nameof(dictionary));
			Code.NotNull(resultSelector, nameof(resultSelector));
			Code.NotNull(defaultValueFactory, nameof(defaultValueFactory));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? resultSelector(key, result)
					: defaultValueFactory(key);
		}
<#+}

		private void ConflictBody4() {#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, resultSelector, defaultValueFactory);
		}
<#+}#>