<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

using JetBrains.Annotations;

using JBNotNull = JetBrains.Annotations.NotNullAttribute;

namespace CodeJam.Collections
{
	partial class EnumerableExtensions
	{
<#
	foreach (var info in new[]
	{
		new { Method = "MinBy", Operator = "<", Name = "minimum" },
		new { Method = "MaxBy", Operator = ">", Name = "maximum" }
	})
	{
#>
		#region <#= info.Method #>

<#
		foreach (var type in new[] { "byte", "sbyte", "short", "ushort", "int", "uint", "long", "ulong", "float", "double", "decimal" })
		{
			var hasNaN = type == "float" || type == "double";
#>
		#region <#= type #>
		/// <summary>
		/// Invokes a <paramref name="selector"/> on each element of a <paramref name="source"/>
		/// and returns the item with minimum value.
		/// </summary>
		/// <typeparam name="TSource">The type of the elements of source.</typeparam>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <returns>The item with <#= info.Name #> value in the sequence.</returns>
		[Pure]
		public static TSource <#= info.Method #><TSource>(
			[JBNotNull, InstantHandle] this IEnumerable<TSource> source,
			[JBNotNull, InstantHandle] Func<TSource, <#= type #>> selector)
		{
			Code.NotNull(source, nameof(source));
			Code.NotNull(selector, nameof(selector));

			TSource item;
			using (var e = source.GetEnumerator())
			{
<#			if (hasNaN) {#>
				<#=type#> value;
				do
				{
					if (!e.MoveNext())
						throw NoElementsException();

					value = selector(e.Current);
				}
				while (<#=type#>.IsNaN(value));
<#			}#>
<#			else {#>
				if (!e.MoveNext())
					throw NoElementsException();

				var value = selector(e.Current);
<#			}#>

				item = e.Current;
				while (e.MoveNext())
				{
					var x = selector(e.Current);
					if (x <#= info.Operator #> value)
					{
						value = x;
						item = e.Current;
					}
				}
			}

			return item;
		}

		/// <summary>
		/// Invokes a <paramref name="selector"/> on each element of a <paramref name="source"/>
		/// and returns the item with minimum value.
		/// </summary>
		/// <typeparam name="TSource">The type of the elements of source.</typeparam>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <param name="defaultValue">Value returned if collection contains no not null elements.</param>
		/// <returns>
		/// The item with <#= info.Name #> value in the sequence or <typeparamref name="TSource"/> default value if
		/// <paramref name="source"/> has no not null elements.
		/// </returns>
		[Pure, CanBeNull]
		[return: MaybeNull]
		public static TSource <#= info.Method #>OrDefault<TSource>(
			[JBNotNull, InstantHandle] this IEnumerable<TSource> source,
			[JBNotNull, InstantHandle] Func<TSource, <#= type #>> selector,
			[MaybeNull] TSource defaultValue = default(TSource))
		{
			Code.NotNull(source, nameof(source));
			Code.NotNull(selector, nameof(selector));

			TSource item;
			using (var e = source.GetEnumerator())
			{
<#			if (hasNaN) {#>
				<#=type#> value;
				do
				{
					if (!e.MoveNext())
						return defaultValue;

					value = selector(e.Current);
				}
				while (<#=type#>.IsNaN(value));
<#			}#>
<#			else {#>
				if (!e.MoveNext())
					return defaultValue;

				var value = selector(e.Current);
<#			}#>
				item = e.Current;
				while (e.MoveNext())
				{
					var x = selector(e.Current);
					if (x <#= info.Operator #> value)
					{
						value = x;
						item = e.Current;
					}
				}
			}

			return item;
		}

		/// <summary>
		/// Invokes a <paramref name="selector"/> on each element of a <paramref name="source"/>
		/// and returns the item with minimum value.
		/// </summary>
		/// <typeparam name="TSource">The type of the elements of source.</typeparam>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <returns>The item with <#= info.Name #> value in the sequence.</returns>
		[Pure]
		public static TSource <#= info.Method #><TSource>(
			[JBNotNull, InstantHandle] this IEnumerable<TSource> source,
			[JBNotNull, InstantHandle] Func<TSource, <#= type #>?> selector)
		{
			Code.NotNull(source, nameof(source));
			Code.NotNull(selector, nameof(selector));

			TSource item;
			using (var e = source.GetEnumerator())
			{
				<#= type #>? value;
				// Start off knowing that we've a non-null value (or exit here, knowing we don't)
				// so we don't have to keep testing for nullity.
				do
				{
					if (!e.MoveNext())
						throw NoElementsException();

					value = selector(e.Current);
				}
<#			if (hasNaN) {#>
				while (<#=type#>.IsNaN(value.GetValueOrDefault(<#=type#>.NaN)));
<#			} else {#>
				while (!value.HasValue);
<#			}#>

				// Keep hold of the wrapped value, and do comparisons on that, rather than
				// using the lifted operation each time.
				var valueVal = value.GetValueOrDefault();
				item = e.Current;
				while (e.MoveNext())
				{
					var cur = selector(e.Current);
					var x = cur.GetValueOrDefault();

					// Do not replace & with &&. The branch prediction cost outweighs the extra operation
					// unless nulls either never happen or always happen.
					if (cur.HasValue & x <#= info.Operator #> valueVal)
					{
						valueVal = x;
						item = e.Current;
					}
				}
			}

			return item;
		}

		/// <summary>
		/// Invokes a <paramref name="selector"/> on each element of a <paramref name="source"/>
		/// and returns the item with minimum value.
		/// </summary>
		/// <typeparam name="TSource">The type of the elements of source.</typeparam>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <param name="defaultValue">Value returned if collection contains no not null elements.</param>
		/// <returns>
		/// The item with <#= info.Name #> value in the sequence or <typeparamref name="TSource"/> default value if
		/// <paramref name="source"/> has no not null elements.
		/// </returns>
		[Pure, CanBeNull]
		[return: MaybeNull]
		public static TSource <#= info.Method #>OrDefault<TSource>(
			[JBNotNull, InstantHandle] this IEnumerable<TSource> source,
			[JBNotNull, InstantHandle] Func<TSource, <#= type #>?> selector,
			[MaybeNull] TSource defaultValue = default(TSource))
		{
			Code.NotNull(source, nameof(source));
			Code.NotNull(selector, nameof(selector));

			TSource item;
			using (var e = source.GetEnumerator())
			{
				<#= type #>? value;
				// Start off knowing that we've a non-null value (or exit here, knowing we don't)
				// so we don't have to keep testing for nullity.
				do
				{
					if (!e.MoveNext())
						return defaultValue;

					value = selector(e.Current);
				}
				while (!value.HasValue);

				// Keep hold of the wrapped value, and do comparisons on that, rather than
				// using the lifted operation each time.
				var valueVal = value.GetValueOrDefault();
				item = e.Current;
				while (e.MoveNext())
				{
					var cur = selector(e.Current);
					var x = cur.GetValueOrDefault();

					// Do not replace & with &&. The branch prediction cost outweighs the extra operation
					// unless nulls either never happen or always happen.
					if (cur.HasValue & x <#= info.Operator #> valueVal)
					{
						valueVal = x;
						item = e.Current;
					}
				}
			}

			return item;
		}
		#endregion

<#
		}
#>
		#endregion

<#
	}
#>
	}
}