<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;

using JetBrains.Annotations;

namespace CodeJam.Collections
{
	partial class ArrayExtensions
	{
<#
	foreach (var type in new[] { "byte", "sbyte", "short", "ushort", "int", "uint", "long", "ulong", "TimeSpan", "Guid" })
	{
		WriteRegionLine(type);
		GenerateUnsafeMethod(type);
	}

	FlushRegions();
#>
	}
}
<#+ private void GenerateUnsafeMethod(string type) { #>
		/// <summary>
		/// Returns true, if length and content of <paramref name="a"/> equals <paramref name="b"/>.
		/// </summary>
		/// <param name="a">The first array to compare.</param>
		/// <param name="b">The second array to compare.</param>
		/// <returns>True, if length and content of <paramref name="a"/> equals <paramref name="b"/>.</returns>
		[Pure]
		public static unsafe bool EqualsTo([CanBeNull] this <#= type #>?[] a, [CanBeNull] <#= type #>[] b)
		{
			if (a == b)
				return true;

			if (a == null || b == null)
				return false;

			if (a.Length != b.Length)
				return false;

<#+ if (type != "Guid") { #>
			if (a.Length < 5)
			{
				for (var i = 0; i < a.Length; i++)
					if (a[i] != b[i])
						return false;

				return true;
			}
<#+ } else { #>
			if (a.Length == 0)
				return true;
<#+ } #>

			fixed (void* pa = &a[0], pb = &b[0])
				return Memory.Compare((byte*)pa, (byte*)pb, a.Length * sizeof(<#= type #>));
		}
<#+ } #>
