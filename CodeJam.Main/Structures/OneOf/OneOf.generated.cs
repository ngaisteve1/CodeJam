//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

using System;

using JetBrains.Annotations;

namespace CodeJam
{
	/// <summary>
	/// Tagged union for 2 types.
	/// </summary>
	/// <typeparam name="T1">Type of case 1</typeparam>
	/// <typeparam name="T2">Type of case 2</typeparam>
	public abstract class OneOf<T1, T2> : IOneOf<T1, T2>, IEquatable<OneOf<T1, T2>>
	{
		/// <inheritdoc />
		public abstract bool IsCase1 { get; }

		/// <inheritdoc />
		public abstract bool IsCase2 { get; }

		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector);

		/// <inheritdoc />
		public abstract void Do(Action<T1> case1Action, Action<T2> case2Action);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<T1, T2> other);

		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<T1, T2> && Equals((OneOf<T1, T2>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<T1, T2> left, OneOf<T1, T2> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<T1, T2> left, OneOf<T1, T2> right) => !Equals(left, right);

		private sealed class Case1 : OneOf<T1, T2>
		{
			private T1 _value;

			public Case1(T1 value)
			{
				_value = value;
			}

			public override bool IsCase1 => true;
			public override bool IsCase2 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector) => case1Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action) => case1Action(_value);

			public override bool Equals(OneOf<T1, T2> other) => Equals(other as Case1);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2}"/> for value of type <typeparamref name="T1"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T1"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2}"/>.</returns>
		public static OneOf<T1, T2> Create([NotNull] T1 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case1(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2}"/> for value of type <typeparamref name="T1"/>.</returns>
		public static implicit operator OneOf<T1, T2>(T1 value) => Create(value);

		private sealed class Case2 : OneOf<T1, T2>
		{
			private T2 _value;

			public Case2(T2 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => true;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector) => case2Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action) => case2Action(_value);

			public override bool Equals(OneOf<T1, T2> other) => Equals(other as Case2);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2}"/> for value of type <typeparamref name="T2"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T2"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2}"/>.</returns>
		public static OneOf<T1, T2> Create([NotNull] T2 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case2(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2}"/> for value of type <typeparamref name="T2"/>.</returns>
		public static implicit operator OneOf<T1, T2>(T2 value) => Create(value);

	}

	/// <summary>
	/// Tagged union for 3 types.
	/// </summary>
	/// <typeparam name="T1">Type of case 1</typeparam>
	/// <typeparam name="T2">Type of case 2</typeparam>
	/// <typeparam name="T3">Type of case 3</typeparam>
	public abstract class OneOf<T1, T2, T3> : IOneOf<T1, T2, T3>, IEquatable<OneOf<T1, T2, T3>>
	{
		/// <inheritdoc />
		public abstract bool IsCase1 { get; }

		/// <inheritdoc />
		public abstract bool IsCase2 { get; }

		/// <inheritdoc />
		public abstract bool IsCase3 { get; }

		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector);

		/// <inheritdoc />
		public abstract void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<T1, T2, T3> other);

		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<T1, T2, T3> && Equals((OneOf<T1, T2, T3>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<T1, T2, T3> left, OneOf<T1, T2, T3> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<T1, T2, T3> left, OneOf<T1, T2, T3> right) => !Equals(left, right);

		private sealed class Case1 : OneOf<T1, T2, T3>
		{
			private T1 _value;

			public Case1(T1 value)
			{
				_value = value;
			}

			public override bool IsCase1 => true;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector) => case1Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action) => case1Action(_value);

			public override bool Equals(OneOf<T1, T2, T3> other) => Equals(other as Case1);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3}"/> for value of type <typeparamref name="T1"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T1"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3}"/>.</returns>
		public static OneOf<T1, T2, T3> Create([NotNull] T1 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case1(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3}"/> for value of type <typeparamref name="T1"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3>(T1 value) => Create(value);

		private sealed class Case2 : OneOf<T1, T2, T3>
		{
			private T2 _value;

			public Case2(T2 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => true;
			public override bool IsCase3 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector) => case2Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action) => case2Action(_value);

			public override bool Equals(OneOf<T1, T2, T3> other) => Equals(other as Case2);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3}"/> for value of type <typeparamref name="T2"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T2"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3}"/>.</returns>
		public static OneOf<T1, T2, T3> Create([NotNull] T2 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case2(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3}"/> for value of type <typeparamref name="T2"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3>(T2 value) => Create(value);

		private sealed class Case3 : OneOf<T1, T2, T3>
		{
			private T3 _value;

			public Case3(T3 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => true;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector) => case3Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action) => case3Action(_value);

			public override bool Equals(OneOf<T1, T2, T3> other) => Equals(other as Case3);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3}"/> for value of type <typeparamref name="T3"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T3"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3}"/>.</returns>
		public static OneOf<T1, T2, T3> Create([NotNull] T3 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case3(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3}"/> for value of type <typeparamref name="T3"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3>(T3 value) => Create(value);

	}

	/// <summary>
	/// Tagged union for 4 types.
	/// </summary>
	/// <typeparam name="T1">Type of case 1</typeparam>
	/// <typeparam name="T2">Type of case 2</typeparam>
	/// <typeparam name="T3">Type of case 3</typeparam>
	/// <typeparam name="T4">Type of case 4</typeparam>
	public abstract class OneOf<T1, T2, T3, T4> : IOneOf<T1, T2, T3, T4>, IEquatable<OneOf<T1, T2, T3, T4>>
	{
		/// <inheritdoc />
		public abstract bool IsCase1 { get; }

		/// <inheritdoc />
		public abstract bool IsCase2 { get; }

		/// <inheritdoc />
		public abstract bool IsCase3 { get; }

		/// <inheritdoc />
		public abstract bool IsCase4 { get; }

		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector);

		/// <inheritdoc />
		public abstract void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<T1, T2, T3, T4> other);

		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<T1, T2, T3, T4> && Equals((OneOf<T1, T2, T3, T4>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<T1, T2, T3, T4> left, OneOf<T1, T2, T3, T4> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<T1, T2, T3, T4> left, OneOf<T1, T2, T3, T4> right) => !Equals(left, right);

		private sealed class Case1 : OneOf<T1, T2, T3, T4>
		{
			private T1 _value;

			public Case1(T1 value)
			{
				_value = value;
			}

			public override bool IsCase1 => true;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector) => case1Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action) => case1Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4> other) => Equals(other as Case1);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T1"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T1"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4}"/>.</returns>
		public static OneOf<T1, T2, T3, T4> Create([NotNull] T1 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case1(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T1"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4>(T1 value) => Create(value);

		private sealed class Case2 : OneOf<T1, T2, T3, T4>
		{
			private T2 _value;

			public Case2(T2 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => true;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector) => case2Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action) => case2Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4> other) => Equals(other as Case2);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T2"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T2"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4}"/>.</returns>
		public static OneOf<T1, T2, T3, T4> Create([NotNull] T2 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case2(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T2"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4>(T2 value) => Create(value);

		private sealed class Case3 : OneOf<T1, T2, T3, T4>
		{
			private T3 _value;

			public Case3(T3 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => true;
			public override bool IsCase4 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector) => case3Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action) => case3Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4> other) => Equals(other as Case3);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T3"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T3"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4}"/>.</returns>
		public static OneOf<T1, T2, T3, T4> Create([NotNull] T3 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case3(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T3"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4>(T3 value) => Create(value);

		private sealed class Case4 : OneOf<T1, T2, T3, T4>
		{
			private T4 _value;

			public Case4(T4 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => true;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector) => case4Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action) => case4Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4> other) => Equals(other as Case4);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T4"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T4"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4}"/>.</returns>
		public static OneOf<T1, T2, T3, T4> Create([NotNull] T4 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case4(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4}"/> for value of type <typeparamref name="T4"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4>(T4 value) => Create(value);

	}

	/// <summary>
	/// Tagged union for 5 types.
	/// </summary>
	/// <typeparam name="T1">Type of case 1</typeparam>
	/// <typeparam name="T2">Type of case 2</typeparam>
	/// <typeparam name="T3">Type of case 3</typeparam>
	/// <typeparam name="T4">Type of case 4</typeparam>
	/// <typeparam name="T5">Type of case 5</typeparam>
	public abstract class OneOf<T1, T2, T3, T4, T5> : IOneOf<T1, T2, T3, T4, T5>, IEquatable<OneOf<T1, T2, T3, T4, T5>>
	{
		/// <inheritdoc />
		public abstract bool IsCase1 { get; }

		/// <inheritdoc />
		public abstract bool IsCase2 { get; }

		/// <inheritdoc />
		public abstract bool IsCase3 { get; }

		/// <inheritdoc />
		public abstract bool IsCase4 { get; }

		/// <inheritdoc />
		public abstract bool IsCase5 { get; }

		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector);

		/// <inheritdoc />
		public abstract void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<T1, T2, T3, T4, T5> other);

		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<T1, T2, T3, T4, T5> && Equals((OneOf<T1, T2, T3, T4, T5>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<T1, T2, T3, T4, T5> left, OneOf<T1, T2, T3, T4, T5> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<T1, T2, T3, T4, T5> left, OneOf<T1, T2, T3, T4, T5> right) => !Equals(left, right);

		private sealed class Case1 : OneOf<T1, T2, T3, T4, T5>
		{
			private T1 _value;

			public Case1(T1 value)
			{
				_value = value;
			}

			public override bool IsCase1 => true;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector) => case1Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action) => case1Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5> other) => Equals(other as Case1);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T1"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T1"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5> Create([NotNull] T1 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case1(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T1"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5>(T1 value) => Create(value);

		private sealed class Case2 : OneOf<T1, T2, T3, T4, T5>
		{
			private T2 _value;

			public Case2(T2 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => true;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector) => case2Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action) => case2Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5> other) => Equals(other as Case2);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T2"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T2"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5> Create([NotNull] T2 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case2(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T2"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5>(T2 value) => Create(value);

		private sealed class Case3 : OneOf<T1, T2, T3, T4, T5>
		{
			private T3 _value;

			public Case3(T3 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => true;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector) => case3Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action) => case3Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5> other) => Equals(other as Case3);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T3"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T3"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5> Create([NotNull] T3 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case3(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T3"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5>(T3 value) => Create(value);

		private sealed class Case4 : OneOf<T1, T2, T3, T4, T5>
		{
			private T4 _value;

			public Case4(T4 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => true;
			public override bool IsCase5 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector) => case4Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action) => case4Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5> other) => Equals(other as Case4);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T4"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T4"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5> Create([NotNull] T4 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case4(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T4"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5>(T4 value) => Create(value);

		private sealed class Case5 : OneOf<T1, T2, T3, T4, T5>
		{
			private T5 _value;

			public Case5(T5 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => true;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector) => case5Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action) => case5Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5> other) => Equals(other as Case5);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T5"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T5"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5> Create([NotNull] T5 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case5(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5}"/> for value of type <typeparamref name="T5"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5>(T5 value) => Create(value);

	}

	/// <summary>
	/// Tagged union for 6 types.
	/// </summary>
	/// <typeparam name="T1">Type of case 1</typeparam>
	/// <typeparam name="T2">Type of case 2</typeparam>
	/// <typeparam name="T3">Type of case 3</typeparam>
	/// <typeparam name="T4">Type of case 4</typeparam>
	/// <typeparam name="T5">Type of case 5</typeparam>
	/// <typeparam name="T6">Type of case 6</typeparam>
	public abstract class OneOf<T1, T2, T3, T4, T5, T6> : IOneOf<T1, T2, T3, T4, T5, T6>, IEquatable<OneOf<T1, T2, T3, T4, T5, T6>>
	{
		/// <inheritdoc />
		public abstract bool IsCase1 { get; }

		/// <inheritdoc />
		public abstract bool IsCase2 { get; }

		/// <inheritdoc />
		public abstract bool IsCase3 { get; }

		/// <inheritdoc />
		public abstract bool IsCase4 { get; }

		/// <inheritdoc />
		public abstract bool IsCase5 { get; }

		/// <inheritdoc />
		public abstract bool IsCase6 { get; }

		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector);

		/// <inheritdoc />
		public abstract void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<T1, T2, T3, T4, T5, T6> other);

		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<T1, T2, T3, T4, T5, T6> && Equals((OneOf<T1, T2, T3, T4, T5, T6>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<T1, T2, T3, T4, T5, T6> left, OneOf<T1, T2, T3, T4, T5, T6> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<T1, T2, T3, T4, T5, T6> left, OneOf<T1, T2, T3, T4, T5, T6> right) => !Equals(left, right);

		private sealed class Case1 : OneOf<T1, T2, T3, T4, T5, T6>
		{
			private T1 _value;

			public Case1(T1 value)
			{
				_value = value;
			}

			public override bool IsCase1 => true;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector) => case1Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action) => case1Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6> other) => Equals(other as Case1);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T1"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T1"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6> Create([NotNull] T1 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case1(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T1"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6>(T1 value) => Create(value);

		private sealed class Case2 : OneOf<T1, T2, T3, T4, T5, T6>
		{
			private T2 _value;

			public Case2(T2 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => true;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector) => case2Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action) => case2Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6> other) => Equals(other as Case2);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T2"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T2"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6> Create([NotNull] T2 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case2(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T2"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6>(T2 value) => Create(value);

		private sealed class Case3 : OneOf<T1, T2, T3, T4, T5, T6>
		{
			private T3 _value;

			public Case3(T3 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => true;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector) => case3Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action) => case3Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6> other) => Equals(other as Case3);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T3"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T3"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6> Create([NotNull] T3 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case3(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T3"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6>(T3 value) => Create(value);

		private sealed class Case4 : OneOf<T1, T2, T3, T4, T5, T6>
		{
			private T4 _value;

			public Case4(T4 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => true;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector) => case4Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action) => case4Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6> other) => Equals(other as Case4);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T4"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T4"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6> Create([NotNull] T4 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case4(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T4"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6>(T4 value) => Create(value);

		private sealed class Case5 : OneOf<T1, T2, T3, T4, T5, T6>
		{
			private T5 _value;

			public Case5(T5 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => true;
			public override bool IsCase6 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector) => case5Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action) => case5Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6> other) => Equals(other as Case5);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T5"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T5"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6> Create([NotNull] T5 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case5(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T5"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6>(T5 value) => Create(value);

		private sealed class Case6 : OneOf<T1, T2, T3, T4, T5, T6>
		{
			private T6 _value;

			public Case6(T6 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => true;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector) => case6Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action) => case6Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6> other) => Equals(other as Case6);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T6"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T6"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6> Create([NotNull] T6 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case6(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6}"/> for value of type <typeparamref name="T6"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6>(T6 value) => Create(value);

	}

	/// <summary>
	/// Tagged union for 7 types.
	/// </summary>
	/// <typeparam name="T1">Type of case 1</typeparam>
	/// <typeparam name="T2">Type of case 2</typeparam>
	/// <typeparam name="T3">Type of case 3</typeparam>
	/// <typeparam name="T4">Type of case 4</typeparam>
	/// <typeparam name="T5">Type of case 5</typeparam>
	/// <typeparam name="T6">Type of case 6</typeparam>
	/// <typeparam name="T7">Type of case 7</typeparam>
	public abstract class OneOf<T1, T2, T3, T4, T5, T6, T7> : IOneOf<T1, T2, T3, T4, T5, T6, T7>, IEquatable<OneOf<T1, T2, T3, T4, T5, T6, T7>>
	{
		/// <inheritdoc />
		public abstract bool IsCase1 { get; }

		/// <inheritdoc />
		public abstract bool IsCase2 { get; }

		/// <inheritdoc />
		public abstract bool IsCase3 { get; }

		/// <inheritdoc />
		public abstract bool IsCase4 { get; }

		/// <inheritdoc />
		public abstract bool IsCase5 { get; }

		/// <inheritdoc />
		public abstract bool IsCase6 { get; }

		/// <inheritdoc />
		public abstract bool IsCase7 { get; }

		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector);

		/// <inheritdoc />
		public abstract void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other);

		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<T1, T2, T3, T4, T5, T6, T7> && Equals((OneOf<T1, T2, T3, T4, T5, T6, T7>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<T1, T2, T3, T4, T5, T6, T7> left, OneOf<T1, T2, T3, T4, T5, T6, T7> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<T1, T2, T3, T4, T5, T6, T7> left, OneOf<T1, T2, T3, T4, T5, T6, T7> right) => !Equals(left, right);

		private sealed class Case1 : OneOf<T1, T2, T3, T4, T5, T6, T7>
		{
			private T1 _value;

			public Case1(T1 value)
			{
				_value = value;
			}

			public override bool IsCase1 => true;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector) => case1Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action) => case1Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other) => Equals(other as Case1);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T1"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T1"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7> Create([NotNull] T1 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case1(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T1"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7>(T1 value) => Create(value);

		private sealed class Case2 : OneOf<T1, T2, T3, T4, T5, T6, T7>
		{
			private T2 _value;

			public Case2(T2 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => true;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector) => case2Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action) => case2Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other) => Equals(other as Case2);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T2"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T2"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7> Create([NotNull] T2 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case2(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T2"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7>(T2 value) => Create(value);

		private sealed class Case3 : OneOf<T1, T2, T3, T4, T5, T6, T7>
		{
			private T3 _value;

			public Case3(T3 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => true;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector) => case3Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action) => case3Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other) => Equals(other as Case3);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T3"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T3"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7> Create([NotNull] T3 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case3(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T3"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7>(T3 value) => Create(value);

		private sealed class Case4 : OneOf<T1, T2, T3, T4, T5, T6, T7>
		{
			private T4 _value;

			public Case4(T4 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => true;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector) => case4Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action) => case4Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other) => Equals(other as Case4);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T4"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T4"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7> Create([NotNull] T4 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case4(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T4"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7>(T4 value) => Create(value);

		private sealed class Case5 : OneOf<T1, T2, T3, T4, T5, T6, T7>
		{
			private T5 _value;

			public Case5(T5 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => true;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector) => case5Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action) => case5Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other) => Equals(other as Case5);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T5"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T5"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7> Create([NotNull] T5 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case5(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T5"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7>(T5 value) => Create(value);

		private sealed class Case6 : OneOf<T1, T2, T3, T4, T5, T6, T7>
		{
			private T6 _value;

			public Case6(T6 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => true;
			public override bool IsCase7 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector) => case6Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action) => case6Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other) => Equals(other as Case6);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T6"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T6"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7> Create([NotNull] T6 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case6(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T6"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7>(T6 value) => Create(value);

		private sealed class Case7 : OneOf<T1, T2, T3, T4, T5, T6, T7>
		{
			private T7 _value;

			public Case7(T7 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => true;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector) => case7Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action) => case7Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7> other) => Equals(other as Case7);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T7"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T7"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7> Create([NotNull] T7 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case7(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7}"/> for value of type <typeparamref name="T7"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7>(T7 value) => Create(value);

	}

	/// <summary>
	/// Tagged union for 8 types.
	/// </summary>
	/// <typeparam name="T1">Type of case 1</typeparam>
	/// <typeparam name="T2">Type of case 2</typeparam>
	/// <typeparam name="T3">Type of case 3</typeparam>
	/// <typeparam name="T4">Type of case 4</typeparam>
	/// <typeparam name="T5">Type of case 5</typeparam>
	/// <typeparam name="T6">Type of case 6</typeparam>
	/// <typeparam name="T7">Type of case 7</typeparam>
	/// <typeparam name="T8">Type of case 8</typeparam>
	public abstract class OneOf<T1, T2, T3, T4, T5, T6, T7, T8> : IOneOf<T1, T2, T3, T4, T5, T6, T7, T8>, IEquatable<OneOf<T1, T2, T3, T4, T5, T6, T7, T8>>
	{
		/// <inheritdoc />
		public abstract bool IsCase1 { get; }

		/// <inheritdoc />
		public abstract bool IsCase2 { get; }

		/// <inheritdoc />
		public abstract bool IsCase3 { get; }

		/// <inheritdoc />
		public abstract bool IsCase4 { get; }

		/// <inheritdoc />
		public abstract bool IsCase5 { get; }

		/// <inheritdoc />
		public abstract bool IsCase6 { get; }

		/// <inheritdoc />
		public abstract bool IsCase7 { get; }

		/// <inheritdoc />
		public abstract bool IsCase8 { get; }

		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector);

		/// <inheritdoc />
		public abstract void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other);

		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<T1, T2, T3, T4, T5, T6, T7, T8> && Equals((OneOf<T1, T2, T3, T4, T5, T6, T7, T8>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> left, OneOf<T1, T2, T3, T4, T5, T6, T7, T8> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> left, OneOf<T1, T2, T3, T4, T5, T6, T7, T8> right) => !Equals(left, right);

		private sealed class Case1 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T1 _value;

			public Case1(T1 value)
			{
				_value = value;
			}

			public override bool IsCase1 => true;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;
			public override bool IsCase8 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case1Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case1Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case1);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T1"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T1"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T1 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case1(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T1"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => Create(value);

		private sealed class Case2 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T2 _value;

			public Case2(T2 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => true;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;
			public override bool IsCase8 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case2Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case2Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case2);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T2"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T2"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T2 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case2(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T2"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => Create(value);

		private sealed class Case3 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T3 _value;

			public Case3(T3 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => true;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;
			public override bool IsCase8 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case3Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case3Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case3);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T3"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T3"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T3 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case3(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T3"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => Create(value);

		private sealed class Case4 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T4 _value;

			public Case4(T4 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => true;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;
			public override bool IsCase8 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case4Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case4Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case4);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T4"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T4"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T4 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case4(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T4"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => Create(value);

		private sealed class Case5 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T5 _value;

			public Case5(T5 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => true;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;
			public override bool IsCase8 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case5Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case5Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case5);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T5"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T5"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T5 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case5(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T5"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => Create(value);

		private sealed class Case6 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T6 _value;

			public Case6(T6 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => true;
			public override bool IsCase7 => false;
			public override bool IsCase8 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case6Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case6Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case6);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T6"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T6"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T6 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case6(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T6"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => Create(value);

		private sealed class Case7 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T7 _value;

			public Case7(T7 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => true;
			public override bool IsCase8 => false;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case7Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case7Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case7);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T7"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T7"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T7 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case7(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T7"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => Create(value);

		private sealed class Case8 : OneOf<T1, T2, T3, T4, T5, T6, T7, T8>
		{
			private T8 _value;

			public Case8(T8 value)
			{
				_value = value;
			}

			public override bool IsCase1 => false;
			public override bool IsCase2 => false;
			public override bool IsCase3 => false;
			public override bool IsCase4 => false;
			public override bool IsCase5 => false;
			public override bool IsCase6 => false;
			public override bool IsCase7 => false;
			public override bool IsCase8 => true;

			public override TResult GetValue<TResult>(Func<T1, TResult> case1Selector, Func<T2, TResult> case2Selector, Func<T3, TResult> case3Selector, Func<T4, TResult> case4Selector, Func<T5, TResult> case5Selector, Func<T6, TResult> case6Selector, Func<T7, TResult> case7Selector, Func<T8, TResult> case8Selector) => case8Selector(_value);

			public override void Do(Action<T1> case1Action, Action<T2> case2Action, Action<T3> case3Action, Action<T4> case4Action, Action<T5> case5Action, Action<T6> case6Action, Action<T7> case7Action, Action<T8> case8Action) => case8Action(_value);

			public override bool Equals(OneOf<T1, T2, T3, T4, T5, T6, T7, T8> other) => Equals(other as Case8);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T8"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T8"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/>.</returns>
		public static OneOf<T1, T2, T3, T4, T5, T6, T7, T8> Create([NotNull] T8 value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case8(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{T1, T2, T3, T4, T5, T6, T7, T8}"/> for value of type <typeparamref name="T8"/>.</returns>
		public static implicit operator OneOf<T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => Create(value);

	}

}