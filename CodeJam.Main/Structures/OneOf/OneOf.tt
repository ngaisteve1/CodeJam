<#@ template debug="false" hostspecific="false" language="C#" #><#@
 include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;

using JetBrains.Annotations;

namespace CodeJam
{
<#for (var i = 2; i <=8; i++) {
	var types = List(i, j => $"T{j}");#>
	/// <summary>
	/// Tagged union for <#=i#> types.
	/// </summary>
<#	for (var k = 1; k <= i; k++){#>
	/// <typeparam name="T<#=k#>">Type of case <#=k#></typeparam>
<#	}#>
	public abstract class OneOf<<#=types#>> : IOneOf<<#=types#>>, IEquatable<OneOf<<#=types#>>>
	{
<#	for (var k = 1; k <= i; k++){#>
		/// <inheritdoc />
		public abstract bool IsCase<#=k#> { get; }

<#	}#>
		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(<#=List(i, j => $"Func<T{j}, TResult> case{j}Selector")#>);

		/// <inheritdoc />
		public abstract void Do(<#=List(i, j => $"Action<T{j}> case{j}Action")#>);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<<#=types#>>? other);

		/// <inheritdoc />
		public override bool Equals(object? obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<<#=types#>> && Equals((OneOf<<#=types#>>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<<#=types#>> left, OneOf<<#=types#>> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<<#=types#>> left, OneOf<<#=types#>> right) => !Equals(left, right);

<#	for (var k = 1; k <= i; k++){#>
		private sealed class Case<#=k#> : OneOf<<#=types#>>
		{
			private T<#=k#> _value;

			public Case<#=k#>(T<#=k#> value)
			{
				_value = value;
			}

<#		for (var l = 1; l <= i; l++){#>
			public override bool IsCase<#=l#> => <#=l == k ? "true" : "false"#>;
<#		}#>

			public override TResult GetValue<TResult>(<#=List(i, j => $"Func<T{j}, TResult> case{j}Selector")#>) => case<#=k#>Selector(_value);

			public override void Do(<#=List(i, j => $"Action<T{j}> case{j}Action")#>) => case<#=k#>Action(_value);

			public override bool Equals(OneOf<<#=types#>>? other) => Equals(other as Case<#=k#>);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{<#=types#>}"/> for value of type <typeparamref name="T<#=k#>"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T<#=k#>"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{<#=types#>}"/>.</returns>
		public static OneOf<<#=types#>> Create([NotNull] T<#=k#> value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case<#=k#>(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{<#=types#>}"/> for value of type <typeparamref name="T<#=k#>"/>.</returns>
		public static implicit operator OneOf<<#=types#>>(T<#=k#> value) => Create(value);

<#	}#>
	}

<#}#>
}