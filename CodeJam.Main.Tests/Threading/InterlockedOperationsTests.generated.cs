//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

using System;
using System.Threading.Tasks;

using NUnit.Framework;

namespace CodeJam.Threading
{
	/// <summary>
	/// Provides a helper class for initializing a values in a thread-safe manner.
	/// </summary>
	[TestFixture(Category = "Threading")]
	public static class InterlockedOperationsTests
	{
		#region double overloads
		[Test]
		public static void TestDoubleInitialize()
		{
			var field = default(double);

			var init = InterlockedOperations.Initialize(ref field, 1.0);
			Assert.That(init, Is.EqualTo(1.0));
			Assert.That(field, Is.EqualTo(1.0));

			init = InterlockedOperations.Initialize(ref field, 2.0);
			Assert.That(init, Is.EqualTo(1.0));
			Assert.That(field, Is.EqualTo(1.0));

			init = InterlockedOperations.Initialize(ref field, 2.0, 1.0);
			Assert.That(init, Is.EqualTo(2.0));
			Assert.That(field, Is.EqualTo(2.0));

			init = InterlockedOperations.Initialize(ref field, 1.0, default(double));
			Assert.That(init, Is.EqualTo(2.0));
			Assert.That(field, Is.EqualTo(2.0));

			init = InterlockedOperations.Initialize(ref field, 1.0, 2.0);
			Assert.That(init, Is.EqualTo(1.0));
			Assert.That(field, Is.EqualTo(1.0));
		}

		[Test]
		public static void TestDoubleUpdate()
		{
			const [NonNegativeValue] int count = 1000;
			var field = default(double);
			var a = 1.0;
			var b = 2.0;

			var updated = InterlockedOperations.Update(ref field, t => a);
			Assert.That(updated, Is.EqualTo(a));
			Assert.That(field, Is.EqualTo(a));

			updated = InterlockedOperations.Update(ref field, b, (t1, t2) => t1 + t2);
			Assert.That(updated, Is.EqualTo(a + b));
			Assert.That(field, Is.EqualTo(a + b));

			var sum = default(double);
			for (int i = 0; i < count; i++)
			{
				sum += a;
			}

			field = default(double);
			Parallel.For(
				0, count,
				i => InterlockedOperations.Update(ref field, a, (t1, t2) => t1 + t2));
			Assert.That(field, Is.EqualTo(sum));
		}
		#endregion

		#region float overloads
		[Test]
		public static void TestFloatInitialize()
		{
			var field = default(float);

			var init = InterlockedOperations.Initialize(ref field, 1.0f);
			Assert.That(init, Is.EqualTo(1.0f));
			Assert.That(field, Is.EqualTo(1.0f));

			init = InterlockedOperations.Initialize(ref field, 2.0f);
			Assert.That(init, Is.EqualTo(1.0f));
			Assert.That(field, Is.EqualTo(1.0f));

			init = InterlockedOperations.Initialize(ref field, 2.0f, 1.0f);
			Assert.That(init, Is.EqualTo(2.0f));
			Assert.That(field, Is.EqualTo(2.0f));

			init = InterlockedOperations.Initialize(ref field, 1.0f, default(float));
			Assert.That(init, Is.EqualTo(2.0f));
			Assert.That(field, Is.EqualTo(2.0f));

			init = InterlockedOperations.Initialize(ref field, 1.0f, 2.0f);
			Assert.That(init, Is.EqualTo(1.0f));
			Assert.That(field, Is.EqualTo(1.0f));
		}

		[Test]
		public static void TestFloatUpdate()
		{
			const [NonNegativeValue] int count = 1000;
			var field = default(float);
			var a = 1.0f;
			var b = 2.0f;

			var updated = InterlockedOperations.Update(ref field, t => a);
			Assert.That(updated, Is.EqualTo(a));
			Assert.That(field, Is.EqualTo(a));

			updated = InterlockedOperations.Update(ref field, b, (t1, t2) => t1 + t2);
			Assert.That(updated, Is.EqualTo(a + b));
			Assert.That(field, Is.EqualTo(a + b));

			var sum = default(float);
			for (int i = 0; i < count; i++)
			{
				sum += a;
			}

			field = default(float);
			Parallel.For(
				0, count,
				i => InterlockedOperations.Update(ref field, a, (t1, t2) => t1 + t2));
			Assert.That(field, Is.EqualTo(sum));
		}
		#endregion

		#region int overloads
		[Test]
		public static void TestIntInitialize()
		{
			var field = default(int);

			var init = InterlockedOperations.Initialize(ref field, 1);
			Assert.That(init, Is.EqualTo(1));
			Assert.That(field, Is.EqualTo(1));

			init = InterlockedOperations.Initialize(ref field, 2);
			Assert.That(init, Is.EqualTo(1));
			Assert.That(field, Is.EqualTo(1));

			init = InterlockedOperations.Initialize(ref field, 2, 1);
			Assert.That(init, Is.EqualTo(2));
			Assert.That(field, Is.EqualTo(2));

			init = InterlockedOperations.Initialize(ref field, 1, default(int));
			Assert.That(init, Is.EqualTo(2));
			Assert.That(field, Is.EqualTo(2));

			init = InterlockedOperations.Initialize(ref field, 1, 2);
			Assert.That(init, Is.EqualTo(1));
			Assert.That(field, Is.EqualTo(1));
		}

		[Test]
		public static void TestIntUpdate()
		{
			const [NonNegativeValue] int count = 1000;
			var field = default(int);
			var a = 1;
			var b = 2;

			var updated = InterlockedOperations.Update(ref field, t => a);
			Assert.That(updated, Is.EqualTo(a));
			Assert.That(field, Is.EqualTo(a));

			updated = InterlockedOperations.Update(ref field, b, (t1, t2) => t1 + t2);
			Assert.That(updated, Is.EqualTo(a + b));
			Assert.That(field, Is.EqualTo(a + b));

			var sum = default(int);
			for (int i = 0; i < count; i++)
			{
				sum += a;
			}

			field = default(int);
			Parallel.For(
				0, count,
				i => InterlockedOperations.Update(ref field, a, (t1, t2) => t1 + t2));
			Assert.That(field, Is.EqualTo(sum));
		}
		#endregion

		#region long overloads
		[Test]
		public static void TestLongInitialize()
		{
			var field = default(long);

			var init = InterlockedOperations.Initialize(ref field, 1L);
			Assert.That(init, Is.EqualTo(1L));
			Assert.That(field, Is.EqualTo(1L));

			init = InterlockedOperations.Initialize(ref field, 2L);
			Assert.That(init, Is.EqualTo(1L));
			Assert.That(field, Is.EqualTo(1L));

			init = InterlockedOperations.Initialize(ref field, 2L, 1L);
			Assert.That(init, Is.EqualTo(2L));
			Assert.That(field, Is.EqualTo(2L));

			init = InterlockedOperations.Initialize(ref field, 1L, default(long));
			Assert.That(init, Is.EqualTo(2L));
			Assert.That(field, Is.EqualTo(2L));

			init = InterlockedOperations.Initialize(ref field, 1L, 2L);
			Assert.That(init, Is.EqualTo(1L));
			Assert.That(field, Is.EqualTo(1L));
		}

		[Test]
		public static void TestLongUpdate()
		{
			const [NonNegativeValue] int count = 1000;
			var field = default(long);
			var a = 1L;
			var b = 2L;

			var updated = InterlockedOperations.Update(ref field, t => a);
			Assert.That(updated, Is.EqualTo(a));
			Assert.That(field, Is.EqualTo(a));

			updated = InterlockedOperations.Update(ref field, b, (t1, t2) => t1 + t2);
			Assert.That(updated, Is.EqualTo(a + b));
			Assert.That(field, Is.EqualTo(a + b));

			var sum = default(long);
			for (int i = 0; i < count; i++)
			{
				sum += a;
			}

			field = default(long);
			Parallel.For(
				0, count,
				i => InterlockedOperations.Update(ref field, a, (t1, t2) => t1 + t2));
			Assert.That(field, Is.EqualTo(sum));
		}
		#endregion

		#region string overloads
		[Test]
		public static void TestStringInitialize()
		{
			var field = default(string);

			var init = InterlockedOperations.Initialize(ref field, "A");
			Assert.That(init, Is.EqualTo("A"));
			Assert.That(field, Is.EqualTo("A"));

			init = InterlockedOperations.Initialize(ref field, "B");
			Assert.That(init, Is.EqualTo("A"));
			Assert.That(field, Is.EqualTo("A"));

			init = InterlockedOperations.Initialize(ref field, "B", "A");
			Assert.That(init, Is.EqualTo("B"));
			Assert.That(field, Is.EqualTo("B"));

			init = InterlockedOperations.Initialize(ref field, "A", default(string));
			Assert.That(init, Is.EqualTo("B"));
			Assert.That(field, Is.EqualTo("B"));

			init = InterlockedOperations.Initialize(ref field, "A", "B");
			Assert.That(init, Is.EqualTo("A"));
			Assert.That(field, Is.EqualTo("A"));
		}

		[Test]
		public static void TestStringUpdate()
		{
			const [NonNegativeValue] int count = 1000;
			var field = default(string);
			var a = "A";
			var b = "B";

			var updated = InterlockedOperations.Update(ref field, t => a);
			Assert.That(updated, Is.EqualTo(a));
			Assert.That(field, Is.EqualTo(a));

			updated = InterlockedOperations.Update(ref field, b, (t1, t2) => t1 + t2);
			Assert.That(updated, Is.EqualTo(a + b));
			Assert.That(field, Is.EqualTo(a + b));

			var sum = default(string);
			for (int i = 0; i < count; i++)
			{
				sum += a;
			}

			field = default(string);
			Parallel.For(
				0, count,
				i => InterlockedOperations.Update(ref field, a, (t1, t2) => t1 + t2));
			Assert.That(field, Is.EqualTo(sum));
		}
		#endregion
	}
}