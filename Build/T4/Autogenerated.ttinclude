<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
<#+
	private string EscapeXmlDocString(string xmlDocText) =>
		new System.Xml.Linq.XText(xmlDocText).ToString();

	private string List(int count, Func<int, string> elem, string separator = ", ") =>
		string.Join(separator, Enumerable.Range(1, count).Select(elem));

	private void WriteLine() => WriteLine("");

	private void WriteSeparatorLine(ref bool notFirstItem)
	{
		if (!notFirstItem)
			notFirstItem = true;
		else
			WriteLine("");
	}

	#region Region helpers
	private class RegionState
	{
		private class RegionData
		{
			public RegionData(string regionName, string regionLevelKey)
			{
				Name = regionName;
				LevelKey = regionLevelKey;
			}

			public string Name { get; private set; }
			public string LevelKey { get; private set; }
		}

		private readonly Stack<RegionData> _regions = new Stack<RegionData>();

		private RegionData FindRegion(string regionLevelKey) =>
			_regions.FirstOrDefault(r => r.LevelKey == regionLevelKey);

		private RegionData[] PopRegions(RegionData region)
		{
			if (region == null) return new RegionData[0];

			var found = false;
			var countToPop = 0;
			foreach (var regionTest in _regions)
			{
				countToPop++;
				if (region == regionTest)
				{
					found = true;
					break;
				}
			}

			if (!found)
				return new RegionData[0];

			var temp = new RegionData[countToPop];
			for (var i = 0; i < countToPop; i++)
				temp[i] = _regions.Pop();
			return temp;
		}

		private void PushRegion(string regionName, string regionLevelKey) =>
			_regions.Push(new RegionData(regionName, regionLevelKey));

		public void WriteRegionLine(
			Action<string> writeLineCallback,
			string regionName,
			string regionLevelKey)
		{
			var region = FindRegion(regionLevelKey);

			if (region == null)
			{
				writeLineCallback("\t\t#region " + regionName);
				PushRegion(regionName, regionLevelKey);
			}
			else if (region.Name == regionName)
			{
				if (region == _regions.Peek())
				{
					writeLineCallback("");
				}
			}
			else
			{
				foreach (var regionToClose in PopRegions(region))
				{
					writeLineCallback("\t\t#endregion");
				}
				writeLineCallback("");
				writeLineCallback("\t\t#region " + regionName);
				PushRegion(regionName, regionLevelKey);
			}
		}

		public void FlushRegions(Action<string> writeLineCallback)
		{
			foreach (var regionToClose in _regions)
			{
				writeLineCallback("\t\t#endregion");
			}
			_regions.Clear();
		}
	}

	private readonly RegionState _regions = new RegionState();

	private void WriteRegionLine(string regionName, string regionLevelKey = "") =>
		_regions.WriteRegionLine(WriteLine, regionName, regionLevelKey);

	private void FlushRegions() => _regions.FlushRegions(WriteLine);
	#endregion
#>